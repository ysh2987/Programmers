# 2021년 9월 30일
# 프로그래머스 Lv2
## N개의 최소공배수
- 두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요.

## 제한조건 
- arr은 길이 1이상, 15이하인 배열입니다.
- arr의 원소는 100 이하인 자연수입니다.
## 입/출력
|arr|result|
|------|---|
|[2,6,8,14]|168|
|[1,2,3]|6|

## 코드
```javascript
function gcd(a,b){
    while (b > 0) {
        let temp = b
        b= a % b
        a = temp
    }
    return a
}

function lcm(a,b){
    return(a*b) / gcd(a,b)
}

function solution(arr) {
    let answer = 1
    for(let i = 0; i < arr.length; i++){
        answer = lcm(answer, arr[i])
    }
    return answer
}
```
## 한줄 평
- 유클리드 호제법과 콜백함수의 개념을 알고있어야 풀 수 있는 문제였다.
- 유클리드 호제법 : 2개의 자연수(또는 정식) a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면(단, a>b), a와 b의 최대공약수는 b와 r의 최대공약수와 같다.
- 이 성질에 따라, b를 r로 나눈 나머지 r'를 구하고, 다시 r을 r'로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수이다.

<br>

# 숫자의 표현

- Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다.
```
1 + 2 + 3 + 4 + 5 = 15
4 + 5 + 6 = 15
7 + 8 = 15
15 = 15
```
- 자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.

## 제한조건 
- n은 10,000 이하의 자연수 입니다.
## 입/출력
|n|result|
|------|---|
|15|4|

## 코드
```javascript
function solution(n) {
    let result = 1
    let sum = 0
    let j = 1

    for (let i =1; i<n; i++){
        sum += i
        if (sum > n ){
            sum = 0
            j++
            i = j
        }
        else if(sum == n){
            result += 1
            sum = 0
            j++
            i = j
        }
    }
    return result
}
```
## 한줄 평
- 완전 탐색 알고리즘으로 문제였지만 n이 n인 경우는 무조건 성립하기 떄문에 result = 1로 지정하고 풀어야 효율성 검사를 통과 할 수 있었다.

# 최소 직사각형(추가된 Lv1문제)
- 명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.
- 아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.

|명함 번호|가로 길이|세로 길이|
|--|--|--|
|1|60|50|
|2|30|70|
|3|60|30|
|4|80|40|

- 가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.

- 모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.

## 제한조건 
- sizes의 길이는 1 이상 10,000 이하입니다.
    - sizes의 원소는 [w, h] 형식입니다.
    - w는 명함의 가로 길이를 나타냅니다.
    - h는 명함의 세로 길이를 나타냅니다.
    - w와 h는 1 이상 1,000 이하인 자연수입니다.
## 입/출력
|sizes|result|
|------|---|
|[[60, 50], [30, 70], [60, 30], [80, 40]]|4000|
|[[10, 7], [12, 3], [8, 15], [14, 7], [5, 15]]|120|
|[[14, 4], [19, 6], [6, 16], [18, 7], [7, 11]]|133|

## 코드
```javascript
function solution(sizes) {
    let w = []
    let h = []
    for(let i=0; i < sizes.length; i++){
        sizes[i].sort((a,b) => a - b)
        w.push(sizes[i][0])
        h.push(sizes[i][1])
    }
    return Math.max(...w) * Math.max(...h)
}
```
## 한줄 평
- 가로와 세로를 변경 할 수 있으므로 각 배열에 큰값을 찾아주면 쉽게 풀 수 있다.